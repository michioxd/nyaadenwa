{"version":3,"file":"worker-B58Y00b7.js","sources":["../src/components/scrcpy/audio/worker.ts"],"sourcesContent":["/*\n * Copyright (c) 2025 michioxd\n * Released under MIT license. See LICENSE for more details.\n * Repository: https://github.com/michioxd/nyaadenwa\n */\n\n/**\n * Modified by michioxd from @yume-chan/pcm-player\n * @author @yume-chan\n * @license MIT\n * @see https://github.com/yume-chan/ya-webadb/blob/main/libraries/pcm-player/worker/worker.ts\n */\nconst INPUT_HOP_SIZE = 3000;\nconst SCALE = 0.9;\nconst OUTPUT_HOP_SIZE = (INPUT_HOP_SIZE * SCALE) | 0;\n\nconst WINDOW_SIZE = 6000;\nconst WINDOW_WEIGHT_TABLE = new Float32Array(WINDOW_SIZE);\nfor (let i = 0; i < WINDOW_SIZE / 2; i += 1) {\n    const value = Math.sin((i / WINDOW_SIZE) * Math.PI);\n    WINDOW_WEIGHT_TABLE[i] = value;\n    WINDOW_WEIGHT_TABLE[WINDOW_SIZE - i - 1] = value;\n}\n\nabstract class SourceProcessor<T> extends AudioWorkletProcessor implements AudioWorkletProcessorImpl {\n    channelCount: number;\n    #readBuffer: Float32Array;\n\n    #chunks: T[] = [];\n    #chunkSampleCounts: number[] = [];\n    #totalSampleCount = 0;\n\n    #starting = true;\n    #speedUp = false;\n    #readOffset = 0;\n    #inputOffset = 0;\n    #outputOffset = 0;\n\n    constructor(options: { outputChannelCount?: number[] }) {\n        super();\n\n        this.channelCount = options.outputChannelCount![0]!;\n        this.#readBuffer = new Float32Array(this.channelCount);\n\n        this.port.onmessage = (event) => {\n            while (this.#totalSampleCount > 0.35 * 48000) {\n                this.#chunks.shift();\n                const count = this.#chunkSampleCounts.shift()!;\n                this.#totalSampleCount -= count;\n            }\n\n            const data = event.data as ArrayBuffer[];\n            const [source, length] = this.createSource(data);\n            this.#chunks.push(source);\n            this.#chunkSampleCounts.push(length);\n            this.#totalSampleCount += length;\n\n            if (!this.#speedUp && this.#totalSampleCount > 0.25 * 48000) {\n                this.#speedUp = true;\n                this.#readOffset = 0;\n                this.#inputOffset = 0;\n                this.#outputOffset = 0;\n            }\n        };\n    }\n\n    protected abstract createSource(data: ArrayBuffer[]): [T, number];\n\n    process(_inputs: Float32Array[][], [outputs]: [Float32Array[]]) {\n        if (this.#starting) {\n            if (this.#totalSampleCount < 0.1 * 48000) {\n                return true;\n            } else {\n                this.#starting = false;\n            }\n        }\n\n        if (this.#speedUp && this.#totalSampleCount < 0.15 * 48000) {\n            this.#speedUp = false;\n            this.#starting = true;\n        }\n\n        const outputLength = outputs[0]!.length;\n\n        if (this.#speedUp) {\n            for (let i = 0; i < outputLength; i += 1) {\n                let totalWeight = 0;\n\n                const firstWindow = Math.max(0, Math.floor((this.#outputOffset - WINDOW_SIZE) / OUTPUT_HOP_SIZE) + 1);\n\n                let inWindowIndex = this.#outputOffset - firstWindow * OUTPUT_HOP_SIZE;\n                let inputIndex = firstWindow * INPUT_HOP_SIZE + inWindowIndex;\n\n                while (inputIndex > 0 && inWindowIndex >= 0) {\n                    this.#read(inputIndex - this.#readOffset);\n                    const weight = WINDOW_WEIGHT_TABLE[inWindowIndex]!;\n                    for (let j = 0; j < this.channelCount; j += 1) {\n                        outputs[j]![i]! += this.#readBuffer[j]! * weight;\n                    }\n                    totalWeight += weight;\n\n                    inputIndex += INPUT_HOP_SIZE - OUTPUT_HOP_SIZE;\n                    inWindowIndex -= OUTPUT_HOP_SIZE;\n                }\n\n                if (totalWeight > 0) {\n                    for (let j = 0; j < this.channelCount; j += 1) {\n                        outputs[j]![i]! /= totalWeight;\n                    }\n                }\n\n                this.#outputOffset += 1;\n                if (firstWindow > 0) {\n                    this.#outputOffset -= OUTPUT_HOP_SIZE;\n                    this.#readOffset -= INPUT_HOP_SIZE;\n                    this.#inputOffset += (1 - SCALE) * INPUT_HOP_SIZE;\n                }\n            }\n\n            this.#inputOffset += outputLength;\n            const firstChunkSampleCount = this.#chunkSampleCounts[0]!;\n            if (firstChunkSampleCount !== undefined && this.#inputOffset >= firstChunkSampleCount) {\n                this.#chunks.shift();\n                this.#chunkSampleCounts.shift();\n                this.#totalSampleCount -= firstChunkSampleCount;\n                this.#readOffset += firstChunkSampleCount;\n                this.#inputOffset -= firstChunkSampleCount;\n            }\n        } else {\n            this.#copyChunks(outputs);\n        }\n\n        return true;\n    }\n\n    #copyChunks(outputs: Float32Array[]) {\n        let outputIndex = 0;\n        const outputLength = outputs[0]!.length;\n\n        while (this.#chunks.length > 0 && outputIndex < outputLength) {\n            let source: T | undefined = this.#chunks[0];\n            let consumedSampleCount = 0;\n            [source, consumedSampleCount, outputIndex] = this.copyChunk(source!, outputs, outputLength, outputIndex);\n\n            this.#totalSampleCount -= consumedSampleCount;\n\n            if (source) {\n                // Output full\n                this.#chunks[0] = source;\n                this.#chunkSampleCounts[0]! -= consumedSampleCount;\n                return;\n            }\n\n            this.#chunks.shift();\n            this.#chunkSampleCounts.shift();\n        }\n    }\n\n    #read(offset: number) {\n        for (let i = 0; i < this.#chunks.length; i += 1) {\n            const length = this.#chunkSampleCounts[i]!;\n\n            if (offset < length) {\n                this.read(this.#chunks[i]!, offset, this.#readBuffer);\n                return;\n            }\n\n            offset -= length;\n        }\n\n        this.#readBuffer.fill(0);\n    }\n\n    protected abstract read(source: T, offset: number, target: Float32Array): void;\n\n    protected abstract copyChunk(\n        source: T,\n        outputs: Float32Array[],\n        outputLength: number,\n        outputIndex: number,\n    ): [source: T | undefined, sourceIndex: number, outputIndex: number];\n}\n\nclass Int16SourceProcessor extends SourceProcessor<Int16Array> implements AudioWorkletProcessorImpl {\n    protected override createSource(data: ArrayBuffer[]): [Int16Array, number] {\n        const source = new Int16Array(data[0]!);\n        return [source, source.length / this.channelCount];\n    }\n\n    protected override read(source: Int16Array, offset: number, target: Float32Array) {\n        const sourceOffset = offset * this.channelCount;\n        for (let i = 0; i < this.channelCount; i += 1) {\n            target[i] = source[sourceOffset + i]! / 0x8000;\n        }\n    }\n\n    protected override copyChunk(\n        source: Int16Array,\n        outputs: Float32Array[],\n        outputLength: number,\n        outputIndex: number,\n    ): [source: Int16Array | undefined, sourceIndex: number, outputIndex: number] {\n        const sourceLength = source.length;\n        let sourceIndex = 0;\n\n        while (sourceIndex < sourceLength) {\n            for (let i = 0; i < this.channelCount; i += 1) {\n                outputs[i]![outputIndex] = source[sourceIndex]! / 0x8000;\n                sourceIndex += 1;\n            }\n            outputIndex += 1;\n\n            if (outputIndex === outputLength) {\n                return [\n                    sourceIndex < sourceLength ? source.subarray(sourceIndex) : undefined,\n                    sourceIndex / this.channelCount,\n                    outputIndex,\n                ];\n            }\n        }\n\n        return [undefined, sourceIndex / this.channelCount, outputIndex];\n    }\n}\n\nclass Float32SourceProcessor extends SourceProcessor<Float32Array> {\n    protected override createSource(data: ArrayBuffer[]): [Float32Array, number] {\n        const source = new Float32Array(data[0]!);\n        return [source, source.length / this.channelCount];\n    }\n\n    protected override read(source: Float32Array, offset: number, target: Float32Array) {\n        const sourceOffset = offset * this.channelCount;\n        for (let i = 0; i < this.channelCount; i += 1) {\n            target[i] = source[sourceOffset + i]!;\n        }\n    }\n\n    protected override copyChunk(\n        source: Float32Array,\n        outputs: Float32Array[],\n        outputLength: number,\n        outputIndex: number,\n    ): [source: Float32Array | undefined, sourceIndex: number, outputIndex: number] {\n        const sourceLength = source.length;\n        let sourceIndex = 0;\n\n        while (sourceIndex < sourceLength) {\n            for (let i = 0; i < this.channelCount; i += 1) {\n                outputs[i]![outputIndex] = source[sourceIndex]!;\n                sourceIndex += 1;\n            }\n            outputIndex += 1;\n\n            if (outputIndex === outputLength) {\n                return [\n                    sourceIndex < sourceLength ? source.subarray(sourceIndex) : undefined,\n                    sourceIndex / this.channelCount,\n                    outputIndex,\n                ];\n            }\n        }\n\n        return [undefined, sourceIndex / this.channelCount, outputIndex];\n    }\n}\n\nclass Float32PlanerSourceProcessor extends SourceProcessor<Float32Array[]> {\n    protected override createSource(data: ArrayBuffer[]): [Float32Array[], number] {\n        const source = data.map((channel) => new Float32Array(channel));\n        return [source, source[0]!.length];\n    }\n\n    protected override read(source: Float32Array[], offset: number, target: Float32Array) {\n        for (let i = 0; i < target.length; i += 1) {\n            target[i] = source[i]![offset]!;\n        }\n    }\n\n    protected override copyChunk(\n        source: Float32Array[],\n        outputs: Float32Array[],\n        outputLength: number,\n        outputIndex: number,\n    ): [source: Float32Array[] | undefined, sourceIndex: number, outputIndex: number] {\n        const sourceLength = source[0]!.length;\n        let sourceIndex = 0;\n\n        while (sourceIndex < sourceLength) {\n            for (let i = 0; i < this.channelCount; i += 1) {\n                outputs[i]![outputIndex] = source[i]![sourceIndex]!;\n            }\n            sourceIndex += 1;\n            outputIndex += 1;\n\n            if (outputIndex === outputLength) {\n                return [\n                    sourceIndex < sourceLength ? source.map((channel) => channel.subarray(sourceIndex)) : undefined,\n                    sourceIndex,\n                    outputIndex,\n                ];\n            }\n        }\n\n        return [undefined, sourceIndex, outputIndex];\n    }\n}\n\nregisterProcessor(\"int16-source-processor\", Int16SourceProcessor);\nregisterProcessor(\"float32-source-processor\", Float32SourceProcessor);\nregisterProcessor(\"float32-planer-source-processor\", Float32PlanerSourceProcessor);\n"],"names":["INPUT_HOP_SIZE","OUTPUT_HOP_SIZE","WINDOW_SIZE","WINDOW_WEIGHT_TABLE","Float32Array","i","value","Math","sin","PI","SourceProcessor","AudioWorkletProcessor","channelCount","readBuffer","chunks","chunkSampleCounts","totalSampleCount","starting","speedUp","readOffset","inputOffset","outputOffset","constructor","options","super","this","outputChannelCount","port","onmessage","event","shift","count","data","source","length","createSource","push","process","_inputs","outputs","outputLength","totalWeight","firstWindow","max","floor","inWindowIndex","inputIndex","read","weight","j","firstChunkSampleCount","copyChunks","outputIndex","consumedSampleCount","copyChunk","offset","fill","registerProcessor","Int16Array","target","sourceOffset","sourceLength","sourceIndex","subarray","map","channel"],"mappings":"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"}